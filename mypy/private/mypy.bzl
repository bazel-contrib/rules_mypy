"""
mypy aspect.

The mypy aspect runs mypy, succeeding if mypy is error free and failing if mypy produces errors. The
result of the aspect is a mypy cache directory, located at [name].mypy_cache. When provided input cache
directories (the results of other mypy builds), the underlying action first attempts to merge the cache
directories.
"""

load("@rules_mypy_pip//:requirements.bzl", "requirement")
load("@rules_python//python:py_binary.bzl", "py_binary")
load("@rules_python//python:py_info.bzl", RulesPythonPyInfo = "PyInfo")

MypyCacheInfo = provider(
    doc = "Output details of the mypy build rule.",
    fields = {
        "directory": "Location of the mypy cache produced by this target.",
    },
)

def _should_ignore_import(imp):
    ignores = [
        "typing-extensions",
        "mypy-extensions",
        "typing_extensions",
        "mypy_extensions",
    ]
    return any([s in imp for s in ignores])

def _opt_out(opt_out_tags, rule_tags):
    "Returns true iff at least one opt_out_tag appears in rule_tags."
    if len(opt_out_tags) == 0:
        return False

    for tag in opt_out_tags:
        if tag in rule_tags:
            return True

    return False

def _opt_in(opt_in_tags, rule_tags):
    "Returns true iff opt_in_tags is empty or at least one of opt_in_tags appears in rule_tags."
    if len(opt_in_tags) == 0:
        return True

    for tag in opt_in_tags:
        if tag in rule_tags:
            return True

    return False

DEP_TYPE_NORMAL = "normal"
DEP_TYPE_OVERRIDDEN = "overridden"  # a dep that has a stub library overriding it
DEP_TYPE_STUB = "stub"

def _get_deps(ctx):
    all_deps = []
    stub_mapping = {
        base_dep.label: stub_dep
        for base_dep, stub_dep in zip(ctx.attr._stubs_keys, ctx.attr._stubs_values)
    }

    for dep in ctx.rule.attr.deps:
        if dep.label in stub_mapping:
            all_deps.append((dep, DEP_TYPE_OVERRIDDEN))
            all_deps.append((stub_mapping[dep.label], DEP_TYPE_STUB))
        else:
            all_deps.append((dep, DEP_TYPE_NORMAL))

    return all_deps

def _get_py_imports(target):
    if RulesPythonPyInfo in target:
        return target[RulesPythonPyInfo].imports.to_list()
    elif PyInfo in target:
        return target[PyInfo].imports.to_list()
    else:
        return []

def _get_main_relpath(p):
    if p == "_main":
        return "."
    elif p.startswith("_main/"):
        return p.removeprefix("_main/")
    else:
        return None

def _to_search_path(dirs):
    return ":".join(sorted({d: None for d in dirs if d and not _should_ignore_import(d)}))

def _get_mypy_env(ctx, all_deps):
    python_path = []

    # normally, mypy looks in the current directory last, but we explicitly want
    # to check the current directory first, to avoid issues where mypy finds the
    # output bin_dir from `generated_dirs` first
    # https://github.com/theoremlp/rules_mypy/issues/88
    mypy_path = ["."]

    # generated files intended to be imported as absolute paths
    mypy_path.append(ctx.bin_dir.path)

    for imp in ctx.rule.attr.imports:
        imp_main = _get_main_relpath(imp)
        if imp_main != None:
            # importing files in same target
            mypy_path.append("{}/{}".format(ctx.label.package, imp_main))

    for dep, dep_type in all_deps:
        if dep_type == DEP_TYPE_OVERRIDDEN:
            continue

        for imp in _get_py_imports(dep):
            imp_main = _get_main_relpath(imp)
            if imp_main != None:
                # source python files
                mypy_path.append(imp_main)

                # source python files generated by bazel rules
                mypy_path.append("{}/{}".format(ctx.bin_dir.path, imp_main))
            else:
                # external dependencies
                python_path.append("external/{}".format(imp))

                # rules_pycross puts external dependencies under generated path
                python_path.append("{}/external/{}".format(ctx.bin_dir.path, imp))

    return {
        "PYTHONPATH": _to_search_path(python_path),
        "MYPYPATH": _to_search_path(mypy_path),
    }

def _mypy_impl(target, ctx):
    # skip non-root targets
    if target.label.workspace_root != "":
        return []

    if RulesPythonPyInfo not in target and PyInfo not in target:
        return []

    # disable if a target is tagged with at least one suppression tag
    if _opt_out(ctx.attr._suppression_tags, ctx.rule.attr.tags):
        return []

    # disable if there are opt-in tags and one is not present
    if not _opt_in(ctx.attr._opt_in_tags, ctx.rule.attr.tags):
        return []

    # ignore rules that don't carry source files like py_proto_library
    if not hasattr(ctx.rule.files, "srcs"):
        return []

    # Exclude non-python sources from custom rules that return PyInfo
    lintable_srcs = [
        s
        for s in ctx.rule.files.srcs
        if "/_virtual_imports/" not in s.short_path and s.extension in ("py", "pyi")
    ]
    if not lintable_srcs:
        return []

    all_deps = _get_deps(ctx)

    mypy_env = _get_mypy_env(ctx, all_deps)

    upstream_caches = [
        dep[MypyCacheInfo].directory
        for dep, _ in all_deps
        if MypyCacheInfo in dep
    ]

    pyi_files = [
        pyi_file
        for dep, _ in all_deps
        if RulesPythonPyInfo in dep and hasattr(dep[RulesPythonPyInfo], "direct_pyi_files")
        for pyi_file in dep[RulesPythonPyInfo].direct_pyi_files.to_list()
    ]

    depsets = [
        dep.default_runfiles.files
        for dep, _ in all_deps
    ]

    output_file = ctx.actions.declare_file(ctx.rule.attr.name + ".mypy_stdout")

    args = ctx.actions.args()
    args.add("--output", output_file)

    result_info = [OutputGroupInfo(mypy = depset([output_file]))]
    if ctx.attr.cache:
        cache_directory = ctx.actions.declare_directory(ctx.rule.attr.name + ".mypy_cache")
        args.add("--cache-dir", cache_directory.path)

        outputs = [output_file, cache_directory]
        result_info.append(MypyCacheInfo(directory = cache_directory))
    else:
        outputs = [output_file]

    args.add_all([c.path for c in upstream_caches], before_each = "--upstream-cache")
    args.add_all(lintable_srcs)

    if hasattr(ctx.attr, "_mypy_ini"):
        args.add("--mypy-ini", ctx.file._mypy_ini.path)
        config_files = [ctx.file._mypy_ini]
    else:
        config_files = []

    extra_env = {"PYTHONNOUSERSITE": "true"}
    if ctx.attr.color:
        # force color on
        extra_env["MYPY_FORCE_COLOR"] = "1"

        # force color on only works if TERM is set to something that supports color
        extra_env["TERM"] = "xterm-256color"

    py_type_files = [x for x in ctx.rule.files.data if x.basename == "py.typed" or x.extension == "pyi"]
    ctx.actions.run(
        mnemonic = "mypy",
        progress_message = "mypy %{label}",
        inputs = depset(
            direct = ctx.rule.files.srcs + py_type_files + pyi_files + upstream_caches + config_files,
            transitive = depsets,
        ),
        outputs = outputs,
        executable = ctx.executable._mypy_cli,
        arguments = [args],
        env = mypy_env | ctx.configuration.default_shell_env | extra_env,
    )

    return result_info

def mypy(
        mypy_cli = None,
        mypy_ini = None,
        stubs = None,
        cache = True,
        color = True,
        suppression_tags = None,
        opt_in_tags = None):
    """
    Create a mypy target inferring upstream caches from deps.

    Args:
        mypy_cli:   (optional) a replacement mypy_cli to use (recommended to produce
                    with mypy_cli macro)
        mypy_ini:   (optional) mypy_ini file to use
        stubs:      (optional) result from load_stubs()
        cache:      (optional, default True) propagate the mypy cache
        color:      (optional, default True) use color in mypy output
        suppression_tags: (optional, default ["no-mypy"]) tags that suppress running
                    mypy on a particular target.
        opt_in_tags: (optional, default []) tags that must be present for mypy to run
                    on a particular target. When specified, this ruleset will _only_
                    run on targets with this tag.

    Returns:
        a mypy aspect.
    """
    additional_attrs = {}

    return aspect(
        implementation = _mypy_impl,
        attr_aspects = ["deps"],
        attrs = {
            "_mypy_cli": attr.label(
                default = mypy_cli or "@rules_mypy//mypy/private:mypy",
                cfg = "exec",
                executable = True,
            ),
            "_mypy_ini": attr.label(
                # we provide a default here because Bazel won't allow Label attrs
                # that are public, or private attrs that have default values of None
                default = mypy_ini or "@rules_mypy//mypy/private:default_mypy.ini",
                allow_single_file = True,
                mandatory = False,
            ),
            # pass the dict[Label, Label] in parts because Bazel doesn't have
            # this kind of attr to pass naturally
            "_stubs_keys": attr.label_list(default = stubs.mapping.keys() if stubs else []),
            "_stubs_values": attr.label_list(default = stubs.mapping.values() if stubs else []),
            "_suppression_tags": attr.string_list(default = suppression_tags or ["no-mypy"]),
            "_opt_in_tags": attr.string_list(default = opt_in_tags or []),
            "cache": attr.bool(default = cache),
            "color": attr.bool(default = color),
        } | additional_attrs,
    )

def _load_stubs_from_requirements(requirements):
    # for a package "foo-bar", maps "foo_bar" to "@pip//foo_bar:pkg"
    parsed_reqs = {}
    for req in requirements:
        parsed_reqs[Label(req).package] = req

    stubs = {}
    for req in requirements:
        req_name = Label(req).package

        if req_name.endswith("_stubs"):
            base_req_name = req_name.removesuffix("_stubs")
        elif req_name.startswith("types_"):
            base_req_name = req_name.removeprefix("types_")
        else:
            continue

        if base_req_name in parsed_reqs:
            base_req = parsed_reqs[base_req_name]
            stubs[base_req] = req

    return stubs

def load_stubs(requirements = [], overrides = {}):
    """
    Generate a mapping of labels to their stubs label. For example:

    ```
    {
        requirement("cachetools"): requirement("types-cachetools"),
    }
    ```

    This can be detected automatically via `requirements`, manually via `overrides`,
    or a combination of both.

    Args:
        requirements: (optional) the full list of requirements from "@pip//:requirements.bzl"
                      to automatically detect stubs from.
        overrides:    (optional) explicitly specified stubs mapping
    """
    stubs = _load_stubs_from_requirements(requirements)
    return struct(
        mapping = stubs | overrides,
    )

def mypy_cli(name, deps = None, mypy_requirement = None, python_version = "3.12", tags = None):
    """
    Produce a custom mypy executable for use with the mypy build rule.

    Args:
        name: name of the binary target this macro produces
        deps: (optional) additional dependencies to include (e.g. mypy plugins)
              (note: must match the Python version of py_binary)
        mypy_requirement: (optional) a replacement mypy requirement
              (note: must match the Python version of py_binary)
        python_version: (optional) the python_version to use for this target.
              Pass None to use the default
              (defaults to a rules_mypy specified version, currently Python 3.12)
        tags: (optional) tags to include in the binary target
    """

    deps = deps or []
    mypy_requirement = mypy_requirement or requirement("mypy")

    py_binary(
        name = name,
        srcs = ["@rules_mypy//mypy/private:mypy_runner.py"],
        main = "@rules_mypy//mypy/private:mypy_runner.py",
        visibility = ["//visibility:public"],
        deps = [mypy_requirement] + deps,
        python_version = python_version,
        tags = tags,
    )
